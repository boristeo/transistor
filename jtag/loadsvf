#!/usr/bin/env python3
import sys
from jtag2232 import JTAG2232 
from binascii import hexlify
import decimal


commands = [
'ENDDR',	    # Specifies default end state for DR scan operations.
'ENDIR',	    # Specifies default end state for IR scan operations.
'FREQUENCY',	# Specifies maximum test clock frequency for IEEE 1149.1 bus operations.
'HDR',	      # (Header Data Register) Specifies a header pattern that is prepended to the beginning of subsequent DR scan operations.
'HIR',	      # (Header Instruction Register) Specifies a header pattern that is prepended to the beginning of subsequent IR scan operations.
'PIO',	      # (Parallel Input/Output) Specifies a parallel test pattern.
'PIOMAP', 	  # (Parallel Input/Output Map) Maps PIO column positions to a logical pin.
'RUNTEST',	  # Forces the IEEE 1149.1 bus to a run state for a specified number of clocks or a specified time period.
'SDR',	      # (Scan Data Register) Performs an IEEE 1149.1 Data Register scan.
'SIR',	      # (Scan Instruction Register) Performs an IEEE 1149.1 Instruction Register scan.
'STATE',	    # Forces the IEEE 1149.1 bus to a specified stable state.
'TDR',        # (Trailer Data Register) Specifies a trailer pattern that is appended to the end of subsequent DR scan operations.
'TIR',        # (Trailer Instruction Register) Specifies a trailer pattern that is appended to the end of subsequent IR scan operations.
'TRST'  	    # (Test ReSeT) Controls the optional Test Reset line.
]

jtagstates = [
'RESET',      # stable (with TMS high); acts as if TRST were pulsed
'RUN', 'IDLE',   # stable; donâ€™t assume this always means IDLE
'DRSELECT', 
'DRCAPTURE', 
'DRSHIFT',    # stable; TDI/TDO shifting through the data register
'DREXIT1', 
'DRPAUSE',    # stable; data register ready for update or more shifting
'DREXIT2', 
'DRUPDATE', 
'IRSELECT', 
'IRCAPTURE', 
'IRSHIFT',    # stable; TDI/TDO shifting through the instruction register
'IREXIT1', 
'IRPAUSE',    # stable; instruction register ready for update or more shifting
'IREXIT2', 
'IRUPDATE', 
]

# Utilities
class SVFParseError(Exception):
  def __init__(self, line, msg):
    super().__init__('Line ' + str(line) + ': ' + msg)

class SVFExecError(Exception):
  def __init__(self, line, msg):
    super().__init__('Line ' + str(line) + ': ' + msg)

def hex_to_val(s):
  return bytearray.fromhex(s.lstrip('(').rstrip(')'))

def equals_with_mask(val, truth, mask, *, masktype):
  assert masktype in ['MASK', 'SMASK']
  for v, t, m in zip(val, truth, mask):
    if (masktype == 'MASK' and v & m != t & m) or (masktype == 'SMASK' and v ^ m != t ^ m):
      return False
  return True

# State
interactive = False
strict = True
jtag = JTAG2232('ftdi://0x403:0x6010/1')

PAUSE_DEBUG = len(sys.argv) > 2 and '-p' in sys.argv

if PAUSE_DEBUG:
  print('Enabled pausing for logic debug. Tag !!PAUSE in SVF comment')

# Open input file or interpret from stdin
try:
  if len(sys.argv) > 1:
    src = open(sys.argv[-1])
  else:
    src = sys.stdin
    interactive = True
except:
  print('Failed to open input file')
  raise

long_send = False
long_send_command = None
long_send_index = None
long_send_data = None

for i, line in enumerate(src, 1):
  if interactive and line.strip() == 'nostrict':
    strict = False
    continue
  try:
    len_code = len(line)
    exc = line.find('!')
    dsl = line.find('//')
    if exc >= 0 or dsl >= 0:
      len_code = min(exc, dsl) + 1
      if PAUSE_DEBUG and '!!PAUSE' in line[len_code:]:
        jtag._sync()
        input('Pausing on line ' + str(i) + ': ' + line[len_code:]) 
    parts = line[:len_code].strip().upper().split()
    if len(parts) == 0:
      continue

    if parts[-1] == ';':
      parts.pop(-1)
      long_send = False
    elif parts[-1][-1] == ';':
      parts[-1] = parts[-1].rstrip(';')
      long_send = False
    elif not strict:
      long_send = False
    elif line.count('(') > line.count(')'):
      long_send = True
    elif long_send:
      pass
    else:
      raise SVFParseError(i, 'Missing ;')

    command = long_send_command or parts[0]
    if long_send:
      long_send_command = command

    if command not in commands:
      raise SVFParseError(i, 'Invalid command "' + parts[0] + '"')
    
    # cases for each operation
    if command == 'STATE':
      assert len(parts) == 2
      if parts[1] == 'RESET':
        jtag.reset()
      elif parts[1] == 'IDLE':
        jtag.idle()
      else:
        raise SVFParseError(i, 'STATE "' + parts[1] + '" not supported')

    elif command == 'TRST':
      assert 2 <= len(parts) <= 3
      if parts[1] != 'OFF':
        raise SVFParseError(i, 'TRST not supported')

    elif command in ['HDR', 'HIR', 'TDR', 'TIR']:
      assert 2 <= len(parts) <= 6
      if interactive and parts[1] == '?':
        print(jtag[parts[0]])
      if int(parts[1]) == 0:
        jtag[parts[0]] = (0, bytearray())
      else:
        assert len(parts) >= 4
        if strict:
          assert parts[2] == 'TDI'
        bitcount = int(parts[1])
        data = hex_to_val(parts[3])
        jtag[parts[0]] = (bitcount, data)
    
    elif command in ['SDR', 'SIR']:
      if not long_send and long_send_index is None: # not continuing from prior send
        if not 4 <= len(parts) <= 8:
          print(i, line)
          assert False
        if strict:
          assert parts[2] == 'TDI'
        capture = len(parts) > 4
        bitcount = int(parts[1])
        data = hex_to_val(parts[3])
        captured = jtag.scan_reg(command[1:], (bitcount, data), capture=capture)

        if len(parts) >= 6:
          assert parts[4] == 'TDO'
          expected = hex_to_val(parts[5])
          maskt = parts[6] if len(parts) >= 8 else 'SMASK'
          mask = hex_to_val(parts[7]) if len(parts) >= 8 else bytearray(len(expected))
          if not equals_with_mask(captured, expected, mask, masktype=maskt):
            raise SVFExecError(i, 'Value captured differs from expected')
          
      elif long_send and long_send_index is None:
        bitcount = int(parts[1])
        long_send_data_len = bitcount
        assert bitcount % 8 == 0
        long_send_data = hex_to_val(parts[3])
        long_send_index = 5
      elif long_send and long_send_index == 5:
        long_send_data.extend(hex_to_val(parts[0]))
      elif not long_send and long_send_index == 5:
        long_send_data.extend(hex_to_val(parts[0]))
        if not len(long_send_data) * 8 == long_send_data_len:
          raise SVFParseError(i, 'Value length differs from expected')
        jtag.scan_reg(command[1:], long_send_data, capture=False)
        long_send_index = None
        long_send_data = None
        long_send_data_len = None
        long_send_command = None 
      else:
        raise NotImplementedError('Long parse not implemented')

    elif command == 'FREQUENCY':
      assert len(parts) >= 3
      if parts[2] == 'HZ':
        hz = int(decimal.Decimal(parts[1]))
      else:
        raise NotImplementedError('Unit for frequency not implemented')
      jtag.set_freq(hz)

    elif command == 'RUNTEST':
      assert len(parts) >= 3
      if parts[2] == 'TCK':
        clks = int(parts[1])
      elif parts[2] == 'SEC':
        secs = decimal.Decimal(parts[1])
        clks = int(secs * jtag.freq)
      else:
        raise NotImplementedError('Unit for runtest not implemented')
      jtag.runtest(clks)

  except Exception as e:
    print(e)
    if not interactive:
      raise

jtag._sync()
