#!/usr/bin/env python3
import sys
from jtag2232 import JTAG2232 
from binascii import hexlify
import decimal


commands = [
'ENDDR',	    # Specifies default end state for DR scan operations.
'ENDIR',	    # Specifies default end state for IR scan operations.
'FREQUENCY',	# Specifies maximum test clock frequency for IEEE 1149.1 bus operations.
'HDR',	      # (Header Data Register) Specifies a header pattern that is prepended to the beginning of subsequent DR scan operations.
'HIR',	      # (Header Instruction Register) Specifies a header pattern that is prepended to the beginning of subsequent IR scan operations.
'PIO',	      # (Parallel Input/Output) Specifies a parallel test pattern.
'PIOMAP', 	  # (Parallel Input/Output Map) Maps PIO column positions to a logical pin.
'RUNTEST',	  # Forces the IEEE 1149.1 bus to a run state for a specified number of clocks or a specified time period.
'SDR',	      # (Scan Data Register) Performs an IEEE 1149.1 Data Register scan.
'SIR',	      # (Scan Instruction Register) Performs an IEEE 1149.1 Instruction Register scan.
'STATE',	    # Forces the IEEE 1149.1 bus to a specified stable state.
'TDR',        # (Trailer Data Register) Specifies a trailer pattern that is appended to the end of subsequent DR scan operations.
'TIR',        # (Trailer Instruction Register) Specifies a trailer pattern that is appended to the end of subsequent IR scan operations.
'TRST'  	    # (Test ReSeT) Controls the optional Test Reset line.
]

jtagstates = [
'RESET',
'IDLE',
'DRSHIFT',
'IRSHIFT',
'DRPAUSE',
'IRPAUSE',
'DRSTOP',
'IRSTOP',
]

# Utilities
class SVFParseError(Exception):
  def __init__(self, line, msg):
    super().__init__('Line ' + str(line) + ': ' + msg)

def hex_to_val(s):
  return bytearray.fromhex(s.lstrip('(').rstrip(')'))

# State
interactive = False
strict = True
jtag = JTAG2232('ftdi://0x403:0x6010/1')

# Open input file or interpret from stdin
try:
  if len(sys.argv) > 1:
    src = open(sys.argv[-1])
  else:
    src = sys.stdin
    interactive = True
except:
  print('Failed to open input file')
  raise

long_send = False
long_send_command = None
long_send_index = None
long_send_data = None

for i, line in enumerate(src, 1):
  if interactive and line.strip() == 'nostrict':
    strict = False
    continue
  try:
    len_code = len(line)
    exc = line.find('!')
    dsl = line.find('//')
    if exc >= 0 or dsl >= 0:
      len_code = min(exc, dsl) + 1
    parts = line[:len_code].strip().upper().split()
    if len(parts) == 0:
      continue

    if parts[-1] == ';':
      parts.pop(-1)
      long_send = False
    elif parts[-1][-1] == ';':
      parts[-1] = parts[-1].rstrip(';')
      long_send = False
    elif not strict:
      long_send = False
    elif line.count('(') > line.count(')'):
      long_send = True
    elif long_send:
      pass
    else:
      raise SVFParseError(i, 'Missing ;')

    command = long_send_command or parts[0]
    if long_send:
      long_send_command = command

    if command not in commands:
      raise SVFParseError(i, 'Invalid command "' + parts[0] + '"')
    
    # cases for each operation
    if command == 'STATE':
      assert len(parts) == 2
      if parts[1] == 'RESET':
        jtag.reset()
      elif parts[1] == 'IDLE':
        jtag.idle()
      else:
        raise SVFParseError(i, 'STATE "' + parts[1] + '" not supported')

    elif command == 'TRST':
      assert 2 <= len(parts) <= 3
      if parts[1] != 'OFF':
        raise SVFParseError(i, 'TRST not supported')

    elif command in ['HDR', 'HIR', 'TDR', 'TIR']:
      assert 2 <= len(parts) <= 6
      if interactive and parts[1] == '?':
        print(jtag[parts[0]])
      if int(parts[1]) == 0:
        jtag[parts[0]] = (0, b'')
      else:
        assert len(parts) >= 4
        if strict:
          assert parts[2] == 'TDI'
        bitcount = int(parts[1])
        data = hex_to_val(parts[3])
        jtag[parts[0]] = (bitcount, data)
    
    elif command in ['SDR', 'SIR']:
      if not long_send and long_send_index is None: # not continuing from prior send
        if not 4 <= len(parts) <= 8:
          print(i, line)
          assert False
        if strict:
          assert parts[2] == 'TDI'
        capture = len(parts) > 4
        bitcount = int(parts[1])
        data = hex_to_val(parts[3])
        captured = jtag.scan_reg(command[1:], (bitcount, data), capture=capture)

        if len(parts) >= 6:
          assert parts[4] == 'TDO'
          expected = hex_to_val(parts[5])
          if len(parts) < 8:
            print('Captured:', hexlify(captured), 'Expected:', hexlify(expected))
          else:
            print('Captured:', hexlify(captured), 'Expected:', hexlify(expected), parts[6], parts[7])
        if len(parts) >= 8:
          if parts[6] == 'MASK':
            pass
          elif parts[6] == 'SMASK':
            pass
          else:
            raise SVFParseError(i, 'Invalid mask type: ' + parts[6])
        elif len(parts) >= 6:
          pass
          
      elif long_send and long_send_index is None:
        bitcount = int(parts[1])
        assert bitcount % 8 == 0
        long_send_data = hex_to_val(parts[3])
        long_send_index = 5
      elif long_send and long_send_index == 5:
        long_send_data.extend(hex_to_val(parts[0]))
      elif not long_send and long_send_index == 5:
        long_send_data.extend(hex_to_val(parts[0]))
        print('Sending %d bytes' % len(long_send_data))
        jtag.scan_reg(command[1:], long_send_data, capture=False)
        long_send_index = None
        long_send_data = None
        long_send_command = None 
      else:
        raise NotImplementedError('Long parse not implemented')

    elif command == 'FREQUENCY':
      assert len(parts) >= 3
      if parts[2] == 'HZ':
        hz = int(decimal.Decimal(parts[1]))
      else:
        raise NotImplementedError('Unit for frequency not implemented')
      jtag.set_freq(hz)

    elif command == 'RUNTEST':
      assert len(parts) >= 3
      if parts[2] == 'TCK':
        clks = int(parts[1])
      elif parts[2] == 'SEC':
        secs = decimal.Decimal(parts[1])
        clks = int(secs * jtag.freq)
      else:
        raise NotImplementedError('Unit for runtest not implemented')
      jtag.idle()
      jtag.write(bytes(clks // 8), use_last=False)

  except Exception as e:
    print(e)
    if not interactive:
      raise
