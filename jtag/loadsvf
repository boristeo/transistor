#!/usr/bin/env python3
import sys
from jtag2232 import JTAG2232 


commands = [
'ENDDR',	    # Specifies default end state for DR scan operations.
'ENDIR',	    # Specifies default end state for IR scan operations.
'FREQUENCY',	# Specifies maximum test clock frequency for IEEE 1149.1 bus operations.
'HDR',	      # (Header Data Register) Specifies a header pattern that is prepended to the beginning of subsequent DR scan operations.
'HIR',	      # (Header Instruction Register) Specifies a header pattern that is prepended to the beginning of subsequent IR scan operations.
'PIO',	      # (Parallel Input/Output) Specifies a parallel test pattern.
'PIOMAP', 	  # (Parallel Input/Output Map) Maps PIO column positions to a logical pin.
'RUNTEST',	  # Forces the IEEE 1149.1 bus to a run state for a specified number of clocks or a specified time period.
'SDR',	      # (Scan Data Register) Performs an IEEE 1149.1 Data Register scan.
'SIR',	      # (Scan Instruction Register) Performs an IEEE 1149.1 Instruction Register scan.
'STATE',	    # Forces the IEEE 1149.1 bus to a specified stable state.
'TDR',        # (Trailer Data Register) Specifies a trailer pattern that is appended to the end of subsequent DR scan operations.
'TIR',        # (Trailer Instruction Register) Specifies a trailer pattern that is appended to the end of subsequent IR scan operations.
'TRST'  	    # (Test ReSeT) Controls the optional Test Reset line.
]

jtagstates = [
'RESET',
'IDLE',
'DRSHIFT',
'IRSHIFT',
'DRPAUSE',
'IRPAUSE',
'DRSTOP',
'IRSTOP',
]


class SVFParseError(Exception):
  def __init__(self, line, msg):
    super().__init__('Line ' + str(line) + ': ' + msg)

# State
interactive = False
strict = True
jtag = JTAG2232('ftdi://0x403:0x6010/1')

# Open input file or interpret from stdin
try:
  if len(sys.argv) > 1:
    src = open(sys.argv[-1])
  else:
    src = sys.stdin
    interactive = True
except:
  print('Failed to open input file')
  raise


for i, line in enumerate(src, 1):
  if interactive and line.strip() == 'nostrict':
    strict = False
    continue
  try:
    len_code = len(line)
    exc = line.find('!')
    dsl = line.find('//')
    if exc >= 0 or dsl >= 0:
      len_code = min(exc, dsl) + 1
    parts = line[:len_code].strip().upper().split()
    if len(parts) == 0:
      continue
    if strict and not parts[-1][-1] == ';':
      raise SVFParseError(i, 'Missing ;')
    parts[-1] = parts[-1].rstrip(';')

    if parts[0] not in commands:
      raise SVFParseError(i, 'Invalid command "' + parts[0] + '"')
    
    # cases for each operation
    if parts[0] == 'STATE':
      assert 3 <= len(parts) <= 4
      if parts[1] == 'RESET':
        jtag.reset()
      elif parts[1] == 'IDLE':
        jtag.idle()
      else:
        raise SVFParseError(i, 'STATE "' + parts[1] + '" not supported')

    elif parts[0] == 'TRST':
      assert 2 <= len(parts) <= 3
      if parts[1] != 'OFF':
        raise SVFParseError(i, 'TRST not supported')

    elif parts[0] in ['HDR', 'HIR', 'TDR', 'TIR']:
      assert 2 <= len(parts) <= 4
      if parts[1] == '?':
        print(jtag[parts[0]])
      assert 4 <= len(parts)
      if strict:
        assert parts[3] == 'TDI'
      jtag[parts[0]] = (int(parts[1]), int(parts[3].lstrip('(').rstrip(')'), 16))

  except Exception as e:
    print(e)
    if not interactive:
      raise
