#!/usr/bin/env python3
import sys
from jtag2232 import JTAG2232 
from binascii import hexlify


commands = [
'ENDDR',	    # Specifies default end state for DR scan operations.
'ENDIR',	    # Specifies default end state for IR scan operations.
'FREQUENCY',	# Specifies maximum test clock frequency for IEEE 1149.1 bus operations.
'HDR',	      # (Header Data Register) Specifies a header pattern that is prepended to the beginning of subsequent DR scan operations.
'HIR',	      # (Header Instruction Register) Specifies a header pattern that is prepended to the beginning of subsequent IR scan operations.
'PIO',	      # (Parallel Input/Output) Specifies a parallel test pattern.
'PIOMAP', 	  # (Parallel Input/Output Map) Maps PIO column positions to a logical pin.
'RUNTEST',	  # Forces the IEEE 1149.1 bus to a run state for a specified number of clocks or a specified time period.
'SDR',	      # (Scan Data Register) Performs an IEEE 1149.1 Data Register scan.
'SIR',	      # (Scan Instruction Register) Performs an IEEE 1149.1 Instruction Register scan.
'STATE',	    # Forces the IEEE 1149.1 bus to a specified stable state.
'TDR',        # (Trailer Data Register) Specifies a trailer pattern that is appended to the end of subsequent DR scan operations.
'TIR',        # (Trailer Instruction Register) Specifies a trailer pattern that is appended to the end of subsequent IR scan operations.
'TRST'  	    # (Test ReSeT) Controls the optional Test Reset line.
]

jtagstates = [
'RESET',
'IDLE',
'DRSHIFT',
'IRSHIFT',
'DRPAUSE',
'IRPAUSE',
'DRSTOP',
'IRSTOP',
]

# Utilities
class SVFParseError(Exception):
  def __init__(self, line, msg):
    super().__init__('Line ' + str(line) + ': ' + msg)

def hex_to_val(s):
  return bytes.fromhex(s.lstrip('(').rstrip(')'))

# State
interactive = False
strict = True
jtag = JTAG2232('ftdi://0x403:0x6010/1')

# Open input file or interpret from stdin
try:
  if len(sys.argv) > 1:
    src = open(sys.argv[-1])
  else:
    src = sys.stdin
    interactive = True
except:
  print('Failed to open input file')
  raise

long_send = False
long_send_command = None
long_send_index = None

for i, line in enumerate(src, 1):
  if interactive and line.strip() == 'nostrict':
    strict = False
    continue
  try:
    len_code = len(line)
    exc = line.find('!')
    dsl = line.find('//')
    if exc >= 0 or dsl >= 0:
      len_code = min(exc, dsl) + 1
    parts = line[:len_code].strip().upper().split()
    if len(parts) == 0:
      continue

    if parts[-1] == ';':
      parts.pop(-1)
      long_send = False
    elif parts[-1][-1] == ';':
      parts[-1] = parts[-1].rstrip(';')
      long_send = False
    elif not strict:
      long_send = False
    elif parts[-1][-1] in '0123456789ABCDEF':
      command = parts[0]
      long_send = True
    else:
      raise SVFParseError(i, 'Missing ;')

    if not long_send:
      command = parts[0]

    if command not in commands:
      raise SVFParseError(i, 'Invalid command "' + parts[0] + '"')
    
    # cases for each operation
    if command == 'STATE':
      assert len(parts) == 2
      if parts[1] == 'RESET':
        jtag.reset()
      elif parts[1] == 'IDLE':
        jtag.idle()
      else:
        raise SVFParseError(i, 'STATE "' + parts[1] + '" not supported')

    elif command == 'TRST':
      assert 2 <= len(parts) <= 3
      if parts[1] != 'OFF':
        raise SVFParseError(i, 'TRST not supported')

    elif command in ['HDR', 'HIR', 'TDR', 'TIR']:
      assert 2 <= len(parts) <= 6
      if interactive and parts[1] == '?':
        print(jtag[parts[0]])
      assert 4 <= len(parts)
      if strict:
        assert parts[2] == 'TDI'
      bitcount = int(parts[1])
      data = hex_to_val(parts[3])
      jtag[parts[0]] = (bitcount, data)
    
    elif command in ['SDR', 'SIR']:
      if long_send_index is None: # not continuing from prior send
        assert 4 <= len(parts) <= 9
        if strict:
          assert parts[2] == 'TDI'
        capture = len(parts) > 4
        bitcount = int(parts[1])
        data = hex_to_val(parts[3])
        captured = jtag.scan_reg(command[1:], (bitcount, data), capture=capture)

        if len(parts) >= 6:
          assert parts[4] == 'TDO'
          expected = hex_to_val(parts[5])
          print('Captured:', hexlify(captured), 'Expected:', hexlify(expected))
        if len(parts) >= 8:
          if parts[6] == 'MASK':
            pass
          elif parts[6] == 'SMASK':
            pass
          else:
            raise SVFParseError(i, 'Invalid mask type: ' + parts[6])
        elif len(parts) >= 6:
          pass
          
        if interactive and captured:
          print(hexlify(captured))
      elif long_send or long_send_index is 5:
        raise NotImplementedError(i, 'Long parse not implemented')

  except Exception as e:
    print(e)
    if not interactive:
      raise
